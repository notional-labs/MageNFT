"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerConnector = void 0;
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const utils_1 = require("@cosmjs/utils");
const ledger_cosmos_js_1 = __importDefault(require("ledger-cosmos-js"));
const semver_1 = __importDefault(require("semver"));
/* eslint-enable */
function unharden(hdPath) {
    return hdPath.map((n) => (n.isHardened() ? n.toNumber() - 2 ** 31 : n.toNumber()));
}
const cosmosHdPath = (0, amino_1.makeCosmoshubPath)(0);
const cosmosBech32Prefix = "cosmos";
const cosmosLedgerAppName = "Cosmos";
const requiredCosmosAppVersion = "1.5.3";
class LedgerConnector {
    constructor(transport, options = {}) {
        var _a, _b, _c, _d, _e;
        const defaultOptions = {
            hdPaths: [cosmosHdPath],
            prefix: cosmosBech32Prefix,
            testModeAllowed: false,
            ledgerAppName: cosmosLedgerAppName,
            requiredLedgerAppVersion: requiredCosmosAppVersion,
        };
        this.testModeAllowed = (_a = options.testModeAllowed) !== null && _a !== void 0 ? _a : defaultOptions.testModeAllowed;
        this.hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;
        this.prefix = (_c = options.prefix) !== null && _c !== void 0 ? _c : defaultOptions.prefix;
        this.ledgerAppName = (_d = options.ledgerAppName) !== null && _d !== void 0 ? _d : defaultOptions.ledgerAppName;
        this.minLedgerAppVersion = (_e = options.minLedgerAppVersion) !== null && _e !== void 0 ? _e : defaultOptions.requiredLedgerAppVersion;
        this.app = new ledger_cosmos_js_1.default(transport);
    }
    async getCosmosAppVersion() {
        await this.verifyCosmosAppIsOpen();
        (0, utils_1.assert)(this.app, `${this.ledgerAppName} Ledger App is not connected`);
        const response = await this.app.getVersion();
        this.handleLedgerErrors(response);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const { major, minor, patch, test_mode: testMode } = response;
        this.verifyAppMode(testMode);
        return `${major}.${minor}.${patch}`;
    }
    async getPubkey(hdPath) {
        await this.verifyDeviceIsReady();
        (0, utils_1.assert)(this.app, `${this.ledgerAppName} Ledger App is not connected`);
        const hdPathToUse = hdPath || this.hdPaths[0];
        // ledger-cosmos-js hardens the first three indices
        const response = await this.app.publicKey(unharden(hdPathToUse));
        this.handleLedgerErrors(response);
        return Uint8Array.from(response.compressed_pk);
    }
    async getPubkeys() {
        return this.hdPaths.reduce((promise, hdPath) => promise.then(async (pubkeys) => [...pubkeys, await this.getPubkey(hdPath)]), Promise.resolve([]));
    }
    async getCosmosAddress(pubkey) {
        const pubkeyToUse = pubkey || (await this.getPubkey());
        return (0, amino_1.pubkeyToAddress)((0, amino_1.encodeSecp256k1Pubkey)(pubkeyToUse), this.prefix);
    }
    async sign(message, hdPath) {
        await this.verifyDeviceIsReady();
        (0, utils_1.assert)(this.app, `${this.ledgerAppName} Ledger App is not connected`);
        const hdPathToUse = hdPath || this.hdPaths[0];
        // ledger-cosmos-js hardens the first three indices
        const response = await this.app.sign(unharden(hdPathToUse), (0, encoding_1.fromUtf8)(message));
        this.handleLedgerErrors(response, "Transaction signing request was rejected by the user");
        return crypto_1.Secp256k1Signature.fromDer(response.signature).toFixedLength();
    }
    verifyAppMode(testMode) {
        if (testMode && !this.testModeAllowed) {
            throw new Error(`DANGER: The ${this.ledgerAppName} Ledger app is in test mode and should not be used on mainnet!`);
        }
    }
    async getOpenAppName() {
        (0, utils_1.assert)(this.app, `${this.ledgerAppName} Ledger App is not connected`);
        const response = await this.app.appInfo();
        this.handleLedgerErrors(response);
        return response.appName;
    }
    async verifyAppVersion() {
        const version = await this.getCosmosAppVersion();
        if (!semver_1.default.gte(version, this.minLedgerAppVersion)) {
            throw new Error(`Outdated version: Please update ${this.ledgerAppName} Ledger App to the latest version.`);
        }
    }
    async verifyCosmosAppIsOpen() {
        const appName = await this.getOpenAppName();
        if (appName.toLowerCase() === `dashboard`) {
            throw new Error(`Please open the ${this.ledgerAppName} Ledger app on your Ledger device.`);
        }
        if (appName.toLowerCase() !== this.ledgerAppName.toLowerCase()) {
            throw new Error(`Please close ${appName} and open the ${this.ledgerAppName} Ledger app on your Ledger device.`);
        }
    }
    async verifyDeviceIsReady() {
        await this.verifyAppVersion();
        await this.verifyCosmosAppIsOpen();
    }
    /**
     * Shows the user's address in the device and returns an address/pubkey pair.
     *
     * The address will be shown with the native prefix of the app (e.g. cosmos, persistence, desmos)
     * and does not support the usage of other address prefixes.
     *
     * @param path The HD path to show the address for. If unset, this is the first account.
     */
    async showAddress(hdPath) {
        await this.verifyDeviceIsReady();
        const hdPathToUse = hdPath || this.hdPaths[0];
        // ledger-cosmos-js hardens the first three indices
        const response = await this.app.showAddressAndPubKey(unharden(hdPathToUse), this.prefix);
        this.handleLedgerErrors(response);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const { address, compressed_pk } = response;
        return {
            address: address,
            pubkey: (0, amino_1.encodeSecp256k1Pubkey)(compressed_pk),
        };
    }
    handleLedgerErrors(
    /* eslint-disable @typescript-eslint/naming-convention */
    { error_message: errorMessage = "No errors", device_locked: deviceLocked = false, }, 
    /* eslint-enable */
    rejectionMessage = "Request was rejected by the user") {
        if (deviceLocked) {
            throw new Error("Ledger’s screensaver mode is on");
        }
        switch (errorMessage) {
            case "U2F: Timeout":
                throw new Error("Connection timed out. Please try again.");
            case "Cosmos app does not seem to be open":
                throw new Error(`${this.ledgerAppName} app is not open`);
            case "Command not allowed":
                throw new Error("Transaction rejected");
            case "Transaction rejected":
                throw new Error(rejectionMessage);
            case "Unknown Status Code: 26628":
                throw new Error("Ledger’s screensaver mode is on");
            case "Instruction not supported":
                throw new Error(`Your ${this.ledgerAppName} Ledger App is not up to date. Please update to version ${this.minLedgerAppVersion} or newer.`);
            case "No errors":
                break;
            default:
                throw new Error(`Ledger Native Error: ${errorMessage}`);
        }
    }
}
exports.LedgerConnector = LedgerConnector;
//# sourceMappingURL=ledgerconnector.js.map