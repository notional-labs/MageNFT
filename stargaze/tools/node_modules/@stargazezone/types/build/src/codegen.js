"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ts_dedupe_1 = require("ts-dedupe");
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
dotenv_1.default.config();
const CONTRACTS_OUTPUT_DIR = ".";
const TSCONFIG_DEFAULT = `{
  "compilerOptions": {
    "target": "es2017",
    "lib": ["esnext"],
    "baseUrl": ".",
    "sourceMap": true
  },
  "include": ["*.ts"],
  "exclude": ["node_modules"]
}    
`;
const CODEGEN_NO_DEDUP = !!process.env.NO_DEDUP;
const CODEGEN_LOG_LEVEL = (() => {
    const logLevel = process.env.CODEGEN_LOG_LEVEL || "";
    if (logLevel === "verbose") {
        return 2;
    }
    if (logLevel === "debug") {
        return 3;
    }
    if (logLevel === "silent") {
        return -1;
    }
    return 1;
})();
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["Silent"] = -1] = "Silent";
    LogLevels[LogLevels["Verbose"] = 2] = "Verbose";
    LogLevels[LogLevels["Debug"] = 3] = "Debug";
    LogLevels[LogLevels["Normal"] = 1] = "Normal";
})(LogLevels || (LogLevels = {}));
function log(msg, level = LogLevels.Normal) {
    if (CODEGEN_LOG_LEVEL < level) {
        return;
    }
    console.log(msg);
}
const DEFAULT_CONFIG = {
    schemaRoots: [
        {
            name: "contracts",
            paths: [process.env.CONTRACTS_ROOT || "../contracts"],
            outputName: "contracts",
            outputDir: CONTRACTS_OUTPUT_DIR,
        },
    ],
    tsconfig: TSCONFIG_DEFAULT,
};
function getSchemaFiles(schemaDir) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const schemaFiles = [];
            fs_1.default.readdir(schemaDir, (err, dirEntries) => {
                if (err) {
                    console.error(err);
                }
                dirEntries.forEach((entry) => {
                    const fullPath = path_1.default.join(schemaDir, entry);
                    if (entry.endsWith(".json") && fs_1.default.existsSync(fullPath)) {
                        schemaFiles.push(fullPath);
                    }
                });
                resolve(schemaFiles);
            });
        });
    });
}
function schemaCompileOptions(contractName, contractRoot, outputDir, schemaDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const schemaFiles = yield getSchemaFiles(schemaDir);
        const outputPath = path_1.default.join(outputDir, contractRoot, contractName);
        const options = Object.assign(Object.assign({}, json_schema_to_typescript_1.DEFAULT_OPTIONS), { bannerComment: "", format: false });
        return {
            contractName,
            schemaDir,
            schemaFiles,
            outputPath,
            options,
        };
    });
}
function deleteFile(filePath) {
    if (!filePath) {
        return;
    }
    if (fs_1.default.existsSync(filePath)) {
        try {
            fs_1.default.unlinkSync(filePath);
        }
        catch (e) {
            console.error(e);
        }
    }
}
function removeDirectory(dir) {
    try {
        fs_1.default.rmdirSync(dir, { recursive: true });
    }
    catch (err) {
        console.error(`Error while deleting ${dir}.`);
    }
}
function writeTsconfig(outputPath, tsconfig = TSCONFIG_DEFAULT) {
    fs_1.default.writeFileSync(path_1.default.join(outputPath, "tsconfig.json"), tsconfig);
}
function run(cmd) {
    return __awaiter(this, void 0, void 0, function* () {
        log(cmd, LogLevels.Verbose);
        return new Promise((resolve, reject) => {
            (0, child_process_1.exec)(cmd, (error, stdout, stderr) => {
                if (error) {
                    console.error(`error: ${error.message}`);
                    reject(error);
                }
                if (stderr) {
                    console.error(`stderr: ${stderr}`);
                    reject(stderr);
                }
                resolve(true);
            });
        });
    });
}
function getSchemaDirectories(rootDir, contracts) {
    return new Promise((resolve, reject) => {
        var _a;
        const contractList = (_a = contracts === null || contracts === void 0 ? void 0 : contracts.split(",").map((dir) => dir.trim())) !== null && _a !== void 0 ? _a : [];
        const directories = [];
        if (contractList.length) {
            // get the schema directory for each contract
            for (const contractName of contractList) {
                const schemaDir = path_1.default.join(rootDir, contractName, "schema");
                directories.push([schemaDir, contractName]);
            }
            resolve(directories);
        }
        else {
            // get all the schema directories in all the contract directories
            fs_1.default.readdir(rootDir, (err, dirEntries) => {
                if (err) {
                    console.error(err);
                    return;
                }
                if (!dirEntries) {
                    console.warn(`no entries found in ${rootDir}`);
                    resolve([]);
                    return;
                }
                dirEntries.forEach((entry) => {
                    try {
                        const schemaDir = path_1.default.resolve(rootDir, entry, "schema");
                        if (fs_1.default.existsSync(schemaDir) &&
                            fs_1.default.lstatSync(schemaDir).isDirectory()) {
                            directories.push([schemaDir, entry]);
                        }
                        else {
                            log(`${schemaDir} is not a directory`, LogLevels.Verbose);
                        }
                    }
                    catch (e) {
                        console.warn(e);
                    }
                });
                resolve(directories);
            });
        }
    });
}
function isEmptyFile(filename) {
    const contents = fs_1.default.readFileSync(filename, "utf8").trim();
    return !contents;
}
function findEmptyFiles(directory) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const emptyFiles = [];
            fs_1.default.readdir(directory, (err, dirEntries) => {
                if (err) {
                    console.error(err);
                    return;
                }
                if (!dirEntries) {
                    console.warn(`no entries found in ${directory}`);
                    resolve([]);
                    return;
                }
                dirEntries.forEach((entry) => {
                    try {
                        const filename = path_1.default.resolve(directory, entry);
                        if (fs_1.default.existsSync(filename) &&
                            !fs_1.default.lstatSync(filename).isDirectory()) {
                            if (isEmptyFile(filename)) {
                                emptyFiles.push(entry.replace(".d.ts", ""));
                            }
                        }
                    }
                    catch (e) {
                        console.warn(e);
                    }
                });
                resolve(emptyFiles);
            });
        });
    });
}
function removeEmptyItems(barrelFile, emptyFiles) {
    const emptyFileSet = new Set(emptyFiles.map((emptyName) => `export * from "./${emptyName}";`));
    const contents = fs_1.default.readFileSync(barrelFile, "utf-8");
    const lines = contents.split("\n");
    const outputLines = [];
    for (const line of lines) {
        if (emptyFileSet.has(line)) {
            outputLines.push(`// dedup emptied this file\n// ${line}`);
        }
        else {
            outputLines.push(line);
        }
    }
    fs_1.default.writeFileSync(barrelFile, outputLines.join("\n"));
}
function dedup(inputPath, outputPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!outputPath) {
            outputPath = inputPath;
        }
        log(`starting dedup files in ${inputPath}...`, LogLevels.Verbose);
        const options = {
            project: path_1.default.join(inputPath, "tsconfig.json"),
            duplicatesFile: path_1.default.join(outputPath, "shared-types.d.ts"),
            barrelFile: path_1.default.join(outputPath, "index.ts"),
            retainEmptyFiles: true,
        };
        if (CODEGEN_LOG_LEVEL === LogLevels.Debug) {
            options.logger = console;
        }
        deleteFile(options.barrelFile);
        deleteFile(options.duplicatesFile);
        yield (0, ts_dedupe_1.dedupe)(options);
        log(`dedup complete for ${outputPath}`, LogLevels.Verbose);
        // Now, remove any files fully emptied by dedup'ing
        // from the index file
        const emptyFiles = yield findEmptyFiles(outputPath);
        if (emptyFiles.length && options.barrelFile) {
            log(`emptyFiles in ${outputPath}: ${emptyFiles}`, LogLevels.Verbose);
            removeEmptyItems(options.barrelFile, emptyFiles);
        }
    });
}
function ensurePath(outputPath) {
    if (fs_1.default.existsSync(outputPath)) {
        return;
    }
    try {
        fs_1.default.mkdirSync(outputPath, { recursive: true });
    }
    catch (e) {
        console.log(e);
    }
}
function compileSchemaFile(schemaFile, spec) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputFile = path_1.default.join(spec.outputPath, path_1.default.basename(schemaFile).replace(".json", ".d.ts"));
        const ts = yield (0, json_schema_to_typescript_1.compileFromFile)(schemaFile, spec.options);
        ensurePath(path_1.default.dirname(outputFile));
        fs_1.default.writeFileSync(outputFile, ts);
    });
}
// Simple-minded function for writing index files not written by dedupe
function writeIndex(outputPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const indexFilePath = path_1.default.join(outputPath, "index.ts");
        if (fs_1.default.existsSync(indexFilePath)) {
            console.error(`${indexFilePath} already exists`);
            return;
        }
        return new Promise((resolve, reject) => {
            const exports = [];
            fs_1.default.readdir(outputPath, (err, dirEntries) => {
                if (err) {
                    console.error(err);
                    reject(err);
                }
                dirEntries.forEach((entry) => {
                    const fullPath = path_1.default.join(outputPath, entry);
                    if (entry.endsWith(".d.ts") && fs_1.default.existsSync(fullPath)) {
                        exports.push(`export * from './${path_1.default.basename(entry, '.d.ts')}'`);
                    }
                });
                fs_1.default.writeFileSync(indexFilePath, exports.join('\n') + '\n');
                resolve(exports);
            });
        });
    });
}
function main() {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        let config = Object.assign({}, DEFAULT_CONFIG);
        const compilationSpecs = [];
        let fileCount = 0;
        log("Calculating generation specs...");
        for (const root of config.schemaRoots) {
            const { name, paths, outputName, outputDir } = root;
            const contractOutputPath = path_1.default.join(outputDir, outputName);
            // log(`Clearing output path ${contractOutputPath}`)
            // removeDirectory(contractOutputPath)
            ensurePath(contractOutputPath);
            for (const path of paths) {
                const schemaDirectories = yield getSchemaDirectories(path);
                for (const [directory, contractName] of schemaDirectories) {
                    const compilationOptions = yield schemaCompileOptions(contractName, outputName, outputDir, directory);
                    fileCount += (_b = (_a = compilationOptions === null || compilationOptions === void 0 ? void 0 : compilationOptions.schemaFiles) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
                    compilationSpecs.push(compilationOptions);
                }
            }
        }
        log(`code generating for ${fileCount} files in ${(_c = compilationSpecs === null || compilationSpecs === void 0 ? void 0 : compilationSpecs.length) !== null && _c !== void 0 ? _c : 0} specs...`);
        if (CODEGEN_LOG_LEVEL === LogLevels.Debug) {
            console.log("Compilation specs:");
            console.dir(compilationSpecs);
        }
        const compilationPromises = [];
        for (const spec of compilationSpecs) {
            for (const schemaFile of spec.schemaFiles) {
                compilationPromises.push(compileSchemaFile(schemaFile, spec));
            }
        }
        yield Promise.all(compilationPromises);
        if (CODEGEN_NO_DEDUP) {
            log(`Skipping dedup step`, LogLevels.Verbose);
        }
        else {
            const dedupPromises = [];
            for (const spec of compilationSpecs) {
                writeTsconfig(spec.outputPath, config.tsconfig);
                dedupPromises.push(dedup(spec.outputPath));
            }
            yield Promise.all(dedupPromises);
            const indexPromises = [];
            for (const spec of compilationSpecs) {
                if (!fs_1.default.existsSync(path_1.default.join(spec.outputPath, "index.ts"))) {
                    indexPromises.push(writeIndex(spec.outputPath));
                }
            }
            yield Promise.all(indexPromises);
        }
        log(`code generation complete`, LogLevels.Normal);
    });
}
main();
